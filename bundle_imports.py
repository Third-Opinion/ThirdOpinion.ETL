#!/usr/bin/env python3
"""
Bundle local imports into a single Python file.

Usage:
    python bundle_imports.py <primary_file.py> [output_file.py]

Example:
    python bundle_imports.py HMUCondition/HMUCondition.py HMUCondition/HMUCondition_bundled.py

This script will:
1. Read the primary file
2. Find import statements for local modules (e.g., "import my_module" or "from my_module import x")
3. Look for ./imports/<module_name>.py
4. Replace the import statement with the contents of that file
5. Write the bundled output
"""

import re
import sys
import os
from pathlib import Path


def find_local_imports(content, imports_dir):
    """
    Find all local import statements that reference files in imports_dir.

    Returns a dict mapping module names to their import lines.
    """
    imports = {}

    # Match "import module_name" or "from module_name import ..."
    import_pattern = r'^(?:from\s+(\w+)\s+import.*|import\s+(\w+))$'

    for line in content.split('\n'):
        match = re.match(import_pattern, line.strip())
        if match:
            module_name = match.group(1) or match.group(2)

            # Check if this module exists in imports directory
            module_path = imports_dir / f"{module_name}.py"
            if module_path.exists():
                imports[module_name] = line

    return imports


def read_module_content(module_path):
    """Read a module file and return its content, stripping shebangs and module docstrings."""
    with open(module_path, 'r') as f:
        content = f.read()

    # Remove shebang line if present
    content = re.sub(r'^#!.*$', '', content, count=1, flags=re.MULTILINE)

    # Remove leading blank lines
    content = content.lstrip('\n')

    return content


def bundle_imports(primary_file, output_file=None, imports_dir='./imports'):
    """
    Bundle local imports into a single file.

    Args:
        primary_file: Path to the primary Python file
        output_file: Path to write bundled output (default: primary_file with _bundled suffix)
        imports_dir: Directory containing importable modules (default: ./imports)
    """
    primary_path = Path(primary_file)
    imports_path = Path(imports_dir)

    if not primary_path.exists():
        print(f"Error: Primary file '{primary_file}' not found")
        sys.exit(1)

    if not imports_path.exists():
        print(f"Warning: Imports directory '{imports_dir}' not found - no imports will be bundled")
        imports_path.mkdir(exist_ok=True)

    # Read primary file
    with open(primary_path, 'r') as f:
        primary_content = f.read()

    # Find all local imports
    local_imports = find_local_imports(primary_content, imports_path)

    if not local_imports:
        print(f"No local imports found in {primary_file}")
        print(f"(Looking for modules in {imports_path}/)")
        return

    print(f"Found {len(local_imports)} local import(s):")
    for module_name in local_imports.keys():
        print(f"  - {module_name}")

    # Build bundled content
    bundled_parts = []

    # Add a header comment
    bundled_parts.append(f"# Bundled from {primary_path.name}\n")
    bundled_parts.append(f"# Generated by bundle_imports.py\n")
    bundled_parts.append(f"# Original imports replaced with inline code\n\n")

    # Add all imported module contents
    for module_name, import_line in local_imports.items():
        module_path = imports_path / f"{module_name}.py"
        module_content = read_module_content(module_path)

        bundled_parts.append(f"# === BEGIN: {module_name} (was: {import_line.strip()}) ===\n")
        bundled_parts.append(module_content)
        bundled_parts.append(f"\n# === END: {module_name} ===\n\n")

    # Add primary file content with imports removed
    modified_content = primary_content
    for module_name, import_line in local_imports.items():
        # Remove the import line
        modified_content = modified_content.replace(import_line, f"# BUNDLED: {import_line.strip()}")

    bundled_parts.append("# === PRIMARY FILE ===\n")
    bundled_parts.append(modified_content)

    # Combine all parts
    bundled_content = ''.join(bundled_parts)

    # Clean up excessive blank lines
    bundled_content = re.sub(r'\n\n\n+', '\n\n', bundled_content)

    # Determine output file
    if output_file is None:
        output_file = primary_path.parent / f"{primary_path.stem}_bundled{primary_path.suffix}"
    else:
        output_file = Path(output_file)

    # Write bundled file
    with open(output_file, 'w') as f:
        f.write(bundled_content)

    print(f"\nâœ“ Created bundled file: {output_file}")
    print(f"  Original size: {len(primary_content):,} bytes")
    print(f"  Bundled size:  {len(bundled_content):,} bytes")


def main():
    if len(sys.argv) < 2:
        print(__doc__)
        sys.exit(1)

    primary_file = sys.argv[1]
    output_file = sys.argv[2] if len(sys.argv) > 2 else None
    imports_dir = sys.argv[3] if len(sys.argv) > 3 else './imports'

    bundle_imports(primary_file, output_file, imports_dir)


if __name__ == '__main__':
    main()
